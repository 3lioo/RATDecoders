import hashlib
import pefile
import io
import yara

from zipfile import ZipFile

# this is a file parser class it will expose the resources, strings and some otheer things about a file.


class FileParser:
    def __init__(self, file_path):
        file_object = open(file_path, 'rb')
        self.file_name = file_object.name
        self.file_data = file_object.read()
        self.file_size = len(self.file_data)
        self.file_family = ''
        file_object.close()

    def file_hash(self, hash_type="sha256"):
        filehash = ''
        if hash_type == "sha256":
            filehash = hashlib.sha256(self.file_data).hexdigest()
        return filehash

    def pe_resource_names(self):
        """
        Read PE Resources and return a list of resource names
        :return: list
        """
        resource_names = []
        pe = pefile.PE(data=self.file_data)
        for rsrc in pe.DIRECTORY_ENTRY_RESOURCE.entries:
            for entry in rsrc.directory.entries:
                if entry.name is not None:
                    resource_names.append(entry.name)
        return resource_names

    def pe_resource_by_name(self, resource_name):
        """
        Extract a PE Resource from a binary by name
        :param resource_name: str
        :return: byte array
        """
        offset = 0x00
        size = 0x00

        pe = pefile.PE(data=self.file_data)
        for rsrc in pe.DIRECTORY_ENTRY_RESOURCE.entries:
            for entry in rsrc.directory.entries:
                if entry.name is not None:
                    if entry.name.__str__() == resource_name:
                        offset = entry.directory.entries[0].data.struct.OffsetToData
                        size = entry.directory.entries[0].data.struct.Size

        return pe.get_memory_mapped_image()[offset:offset + size]

    def dotnet_resource(self, resource_name):
        """
        Extract a .NET Resource by name
        :param resource_name:
        :return:
        """
        rules = yara.compile(source='import "dotnet" rule a { condition: false }')

        def modules_callback(data):
            for i, resource in enumerate(data.get('resources', [])):
                offset = resource['offset']
                length = resource['length']
                print(dir(resource))
                resource_data = self.file_data[offset:offset + length]
                print(resource_data[:4])

            return yara.CALLBACK_CONTINUE

        rules.match(data=self.file_data, modules_callback=modules_callback)

    def dotnet_guids(self):
        """
        Exrtract GUIDS from a .NET Binary
        :return: list of guids
        """
        rules = yara.compile(source='import "dotnet" rule a { condition: false }')
        guid_list = []

        def modules_callback(data):
            for i, guid in enumerate(data.get('guids', [])):
                guid_list.append(guid.decode('utf-8'))
            return yara.CALLBACK_CONTINUE

        rules.match(data=self.file_data, modules_callback=modules_callback)
        return guid_list

    def dotnet_user_strings(self):
        """
        Parse a list of User Strings from a .NET Binary file
        :return: list of strings
        """
        rules = yara.compile(source='import "dotnet" rule a { condition: false }')
        user_strings = []

        def modules_callback(data):
            for i, userstring in enumerate(data.get('user_strings', [])):
                # Remove null bytes
                userstring = userstring.replace(b'\x00', b'')

                # Add string to list
                user_strings.append(userstring.decode('utf-8'))

            return yara.CALLBACK_CONTINUE

        rules.match(data=self.file_data, modules_callback=modules_callback)

        return user_strings

    def file_from_zip(self, filename):
        new_zip = io.BytesIO(self.file_data)
        with ZipFile(new_zip, 'r') as open_zip:
            for name in open_zip.namelist():
                if name == filename:
                    zip_data = open_zip.read(name)
                    return zip_data

    def zip_namelist(self):
        new_zip = io.BytesIO(self.file_data)
        filelist = []
        with ZipFile(new_zip, 'r') as open_zip:
            for name in open_zip.namelist():
                filelist.append(name)
        return filelist
